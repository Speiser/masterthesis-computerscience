
@article{taibi_definition_2018,
	title = {On the {Definition} of {Microservice} {Bad} {Smells}},
	volume = {35},
	issn = {1937-4194},
	doi = {10.1109/MS.2018.2141031},
	abstract = {Code smells and architectural smells (also called bad smells) are symptoms of poor design that can hinder code understandability and decrease maintainability. Several bad smells have been defined in the literature for both generic architectures and specific architectures. However, cloud-native applications based on microservices can be affected by other types of issues. In order to identify a set of microservice-specific bad smells, researchers collected evidence of bad practices by interviewing 72 developers with experience in developing systems based on microservices. Then, they classified the bad practices into a catalog of 11 microservice-specific bad smells frequently considered harmful by practitioners. The results can be used by practitioners and researchers as a guideline to avoid experiencing the same difficult situations in the systems they develop.},
	number = {3},
	journal = {IEEE Software},
	author = {Taibi, Davide and Lenarduzzi, Valentina},
	month = may,
	year = {2018},
	keywords = {anti-pattern, antipattern, architectural smell, architectural smells, bad smell, cloud computing, Cloud computing, cloud-native applications, code smell, code understandability, generic architectures, Interviews, Logic gates, microservice, microservice bad smells, microservice-specific bad smells, public domain software, Service computing, software architecture, Software architecture, software development, Software development, software engineering, Software engineering, software quality, specific architectures},
	pages = {56--62},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\GB5JCICD\\8354414.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Speiser\\Zotero\\storage\\IEN8FADL\\Taibi and Lenarduzzi - 2018 - On the Definition of Microservice Bad Smells.pdf:application/pdf}
}

@inproceedings{bandeira_we_2019,
	title = {We {Need} to {Talk} {About} {Microservices}: an {Analysis} from the {Discussions} on {StackOverflow}},
	shorttitle = {We {Need} to {Talk} {About} {Microservices}},
	doi = {10.1109/MSR.2019.00051},
	abstract = {Microservices are a new and rapidly growing architectural model aimed at developing highly scalable software solutions based on independently deployable and evolvable components. Due to its novelty, microservice-related discussions are increasing in Q\&A websites, such as StackOverflow (SO). In order to understand what is being discussed by the microservice community, this work has applied mining techniques and topic modelling to a manually-curated dataset of 1,043 microservice-related posts from StackOverflow. As a result, we found that 13.68\% of microservice technical posts on SO discuss a single technology: Netflix Eureka. Moreover, buzzwords in the microservice ecosystem, e.g., blue/green deployment, were not identified as relevant subjects of discussion on SO. Finally, we show how a high discussion rate on SO may not reflect the popularity of a certain subject within the microservice community.},
	booktitle = {2019 {IEEE}/{ACM} 16th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
	author = {Bandeira, Alan and Medeiros, Carlos Alberto and Paixao, Matheus and Maia, Paulo Henrique},
	month = may,
	year = {2019},
	note = {ISSN: 2574-3848},
	keywords = {architectural model, data mining, microservice community, microservice ecosystem, microservice-related discussions, microservices, Microservices, StackOverflow, Topic Modelling, mining, Netflix Eureka, Q\&A Websites, question answering (information retrieval), StackOverflow, topic modelling, Web services, Web sites},
	pages = {255--259},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\PTYTGE3H\\8816756.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Speiser\\Zotero\\storage\\FNWVF763\\Bandeira et al. - 2019 - We Need to Talk About Microservices an Analysis f.pdf:application/pdf}
}

@inproceedings{taibi_architectural_2018,
	title = {Architectural {Patterns} for {Microservices}: {A} {Systematic} {Mapping} {Study}},
	shorttitle = {Architectural {Patterns} for {Microservices}},
	doi = {10.5220/0006798302210232},
	abstract = {Microservices is an architectural style increasing in popularity. However, there is still a lack of understanding how to adopt a microservice-based architectural style. We aim at characterizing different microservice architectural style patterns and the principles that guide their definition. We conducted a systematic mapping study in order to identify reported usage of microservices and based on these use cases extract common patterns and principles. We present two key contributions. Firstly, we identified several agreed microservice architecture patterns that seem widely adopted and reported in the case studies identified. Secondly, we presented these as a catalogue in a common template format including a summary of the advantages, disadvantages, and lessons learned for each pattern from the case studies. We can conclude that different architecture patterns emerge for different migration, orchestration, storage and deployment settings for a set of agreed principles.},
	booktitle = {{CLOSER}},
	author = {Taibi, Davide and Lenarduzzi, Valentina and Pahl, Claus},
	year = {2018},
	keywords = {Architectural pattern, Microservices, Software deployment},
	file = {Full Text PDF:C\:\\Users\\Speiser\\Zotero\\storage\\YHBTUWRX\\Taibi et al. - 2018 - Architectural Patterns for Microservices A System.pdf:application/pdf}
}

@article{imranur_curated_2019,
	title = {A curated {Dataset} of {Microservices}-{Based} {Systems}},
	url = {http://arxiv.org/abs/1909.03249},
	abstract = {Microservices based architectures are based on a set of modular, independent and fault-tolerant services. In recent years, the software engineering community presented studies investigating potential, recurrent, effective architectural patterns in microservices-based architectures, as they are very essential to maintain and scale microservice-based systems. Indeed, the organizational structure of such systems should be reflected in so-called microservice architecture patterns, that best fit the projects and development teams needs. However, there is a lack of public repositories sharing open sources projects microservices patterns and practices, which could be beneficial for teaching purposes and future research investigations. This paper tries to fill this gap, by sharing a dataset, having a first curated list microservice-based projects. Specifically, the dataset is composed of 20 open-source projects, all using specific microservice architecture patterns. Moreover, the dataset also reports information about inter-service calls or dependencies of the aforementioned projects. For the analysis, we used two different tools (1) SLOCcount and (2) MicroDepGraph to get different parameters for the microservice dataset. Both the microservice dataset and analysis tool are publicly available online. We believe that this dataset will be highly used by the research community for understanding more about microservices architectural and dependencies patterns, enabling researchers to compare results on common projects.},
	urldate = {2019-12-06},
	journal = {arXiv:1909.03249 [cs]},
	author = {Imranur, Mohammad and Rahman and Panichella, Sebastiano and Taibi, Davide},
	month = sep,
	year = {2019},
	note = {arXiv: 1909.03249},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\Speiser\\Zotero\\storage\\A9DAMZRI\\Imranur et al. - 2019 - A curated Dataset of Microservices-Based Systems.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\Speiser\\Zotero\\storage\\ST3WFCM3\\1909.html:text/html}
}

@article{taibi_monolithic_2019,
	title = {From {Monolithic} {Systems} to {Microservices}: {An} {Assessment} {Framework}},
	shorttitle = {From {Monolithic} {Systems} to {Microservices}},
	url = {http://arxiv.org/abs/1909.08933},
	abstract = {Context. Re-architecting monolithic systems with Microservices-based architecture is a common trend. Various companies are migrating to Microservices for different reasons. However, making such an important decision like re-architecting an entire system must be based on real facts and not only on gut feelings. Objective. The goal of this work is to propose an evidence-based decision support framework for companies that need to migrate to Microservices, based on the analysis of a set of characteristics and metrics they should collect before re-architecting their monolithic system. Method. We designed this study with a mixed-methods approach combining a Systematic Mapping Study with a survey done in the form of interviews with professionals to derive the assessment framework based on Grounded Theory. Results. We identified a set consisting of information and metrics that companies can use to decide whether to migrate to Microservices or not. The proposed assessment framework, based on the aforementioned metrics, could be useful for companies if they need to migrate to Microservices and do not want to run the risk of failing to consider some important information.},
	urldate = {2019-12-17},
	journal = {arXiv:1909.08933 [cs]},
	author = {Taibi, Davide and Auer, Florian and Lenarduzzi, Valentina and Felderer, Michael},
	month = sep,
	year = {2019},
	note = {arXiv: 1909.08933},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\Speiser\\Zotero\\storage\\XGN662RX\\Taibi et al. - 2019 - From Monolithic Systems to Microservices An Asses.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\Speiser\\Zotero\\storage\\CJIK2BIS\\1909.html:text/html}
}

@article{taibi_processes_2017,
	title = {Processes, {Motivations}, and {Issues} for {Migrating} to {Microservices} {Architectures}: {An} {Empirical} {Investigation}},
	volume = {4},
	issn = {2372-2568},
	shorttitle = {Processes, {Motivations}, and {Issues} for {Migrating} to {Microservices} {Architectures}},
	doi = {10.1109/MCC.2017.4250931},
	abstract = {In this paper, we identify a process framework based on the comparison of three different migration processes adopted by the interviewed practitioners, together with the common motivations and issues that commonly take place during migrations. In this work, we describe the results and provide an analysis of our survey, which includes a comparison of the migration processes, a ranking of motivations, and issues and some insights into the benefits achieved after the adoption. Maintainability and scalability were consistently ranked as the most important motivations, along with a few other technical and nontechnical motivations. Although return on investment was expected to take longer, the reduced maintenance effort in the long run was considered to highly compensate for this.},
	number = {5},
	journal = {IEEE Cloud Computing},
	author = {Taibi, Davide and Lenarduzzi, Valentina and Pahl, Claus},
	month = sep,
	year = {2017},
	keywords = {cloud computing, Cloud computing, software architecture, microservices, Web services, cloud containers, cloud migration, cloud native, Companies, Computer architecture, Docker, Investment, maintainability motivation, Maintenance engineering, microservice architectures, migration processes, nontechnical motivation, return on investment, Scalability, scalability motivation, service oriented architectures SOA, technical motivations},
	pages = {22--32},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\5YIEM67C\\8125558.html:text/html}
}

@article{balalaie_microservices_2016,
	title = {Microservices {Architecture} {Enables} {DevOps}: {Migration} to a {Cloud}-{Native} {Architecture}},
	volume = {33},
	issn = {1937-4194},
	shorttitle = {Microservices {Architecture} {Enables} {DevOps}},
	doi = {10.1109/MS.2016.64},
	abstract = {This article reports on experiences and lessons learned during incremental migration and architectural refactoring of a commercial mobile back end as a service to microservices architecture. It explains how the researchers adopted DevOps and how this facilitated a smooth migration.},
	number = {3},
	journal = {IEEE Software},
	author = {Balalaie, Armin and Heydarnoori, Abbas and Jamshidi, Pooyan},
	month = may,
	year = {2016},
	keywords = {cloud computing, Cloud computing, software architecture, Software architecture, software development, software engineering, microservices, Microservices, Computer architecture, Scalability, architectural refactoring, cloud-native architecture, DevOps, incremental migration, microservices architecture, migration pattern, mobile back end as a service, Mobile communication, Refractoring, Servers, software maintenance},
	pages = {42--52},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\SFG43SZI\\7436659.html:text/html;Submitted Version:C\:\\Users\\Speiser\\Zotero\\storage\\QISP9VHL\\Balalaie et al. - 2016 - Microservices Architecture Enables DevOps Migrati.pdf:application/pdf}
}

@incollection{taibi_microservices_2020,
	address = {Cham},
	title = {Microservices {Anti}-patterns: {A} {Taxonomy}},
	isbn = {978-3-030-31646-4},
	shorttitle = {Microservices {Anti}-patterns},
	url = {https://doi.org/10.1007/978-3-030-31646-4_5},
	abstract = {Several companies are rearchitecting their monolithic information systems with microservices. However, many companies migrate to microservices without experience, mainly learning how to migrate from books or from practitioners’ blogs. Because of the novelty of the topic, practitioners and consultancies are learning by doing how to migrate, thus facing several issues but also several benefits. In this chapter, we introduce a catalog and a taxonomy of the most common microservices anti-patterns in order to identify common problems. Our anti-pattern catalog is based on the experience summarized by different practitioners we interviewed in the last 3 years. We identified a taxonomy of 20 anti-patterns, including organizational (team oriented and technology/tool oriented) anti-patterns and technical (internal and communication) anti-patterns. The results can be useful to practitioners to avoid experiencing the same difficult situations in the systems they develop. Moreover, researchers can benefit from this catalog and further validate the harmfulness of the anti-patterns identified.},
	language = {en},
	urldate = {2019-12-17},
	booktitle = {Microservices: {Science} and {Engineering}},
	publisher = {Springer International Publishing},
	author = {Taibi, Davide and Lenarduzzi, Valentina and Pahl, Claus},
	editor = {Bucchiarone, Antonio and Dragoni, Nicola and Dustdar, Schahram and Lago, Patricia and Mazzara, Manuel and Rivera, Victor and Sadovykh, Andrey},
	year = {2020},
	doi = {10.1007/978-3-030-31646-4_5},
	pages = {111--128}
}

@article{neri_design_2019,
	title = {Design principles, architectural smells and refactorings for microservices: a multivocal review},
	issn = {2524-8529},
	shorttitle = {Design principles, architectural smells and refactorings for microservices},
	url = {https://doi.org/10.1007/s00450-019-00407-8},
	doi = {10.1007/s00450-019-00407-8},
	abstract = {Potential benefits such as agile service delivery have led many companies to deliver their business capabilities through microservices. Bad smells are however always around the corner, as witnessed by the considerable body of literature discussing architectural smells that possibly violate the design principles of microservices. In this paper, we systematically review the white and grey literature on the topic, in order to identify the most recognised architectural smells for microservices and to discuss the architectural refactorings allowing to resolve them.},
	language = {en},
	urldate = {2019-12-17},
	journal = {SICS Software-Intensive Cyber-Physical Systems},
	author = {Neri, Davide and Soldani, Jacopo and Zimmermann, Olaf and Brogi, Antonio},
	month = sep,
	year = {2019}
}

@article{lenarduzzi_does_2019,
	title = {Does {Migrate} a {Monolithic} {System} to {Microservices} {Decrease} the {Technical} {Debt}?},
	url = {http://arxiv.org/abs/1902.06282},
	abstract = {Background. The migration from monolithic systems to microservices involves deep refactoring of the systems. Therefore, the migration usually has a big economic impact and companies tend to postpone several activities during this process, mainly to speed-up the migration itself, but also because of the need to release new features. Objective. We monitored the Technical Debt of a small and medium enterprise while migrating a legacy monolithic system to an ecosystem of microservices to analyze changes in the code technical debt before and after the migration to microservices. Method. We conducted a case study analyzing more than four years of the history of a big project (280K Lines of Code) where two teams extracted five business processes from the monolithic system as microservices, by first analyzing the Technical Debt with SonarQube and then performing a qualitative study with the developers to understand the perceived quality of the system and the motivation for eventually postponed activities. Result. The development of microservices helps to reduce the Technical Debt in the long run. Despite an initial spike in the Technical Debt, due to the development of the new microservice, after a relatively short period, the Technical Debt tends to grow slower than in the monolithic system.},
	urldate = {2019-12-17},
	journal = {arXiv:1902.06282 [cs]},
	author = {Lenarduzzi, Valentina and Lomio, Francesco and Saarimäki, Nyyti and Taibi, Davide},
	month = aug,
	year = {2019},
	note = {arXiv: 1902.06282},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\Speiser\\Zotero\\storage\\2XSX9GIE\\Lenarduzzi et al. - 2019 - Does Migrate a Monolithic System to Microservices .pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\Speiser\\Zotero\\storage\\RNBHSPE2\\1902.html:text/html}
}

@inproceedings{taibi_continuous_2018,
	title = {Continuous {Architecting} with {Microservices} and {DevOps}: {A} {Systematic} {Mapping} {Study}},
	shorttitle = {Continuous {Architecting} with {Microservices} and {DevOps}},
	doi = {10.1007/978-3-030-29193-8_7},
	abstract = {Context: Several companies are migrating their information systems into the Cloud. Microservices and DevOps are two of the most common adopted technologies. However, there is still a lack of understanding how to adopt a microservice-based architectural style and which tools and technique to use in a continuous architecting pipeline. Objective: We aim at characterizing the different microservice architectural style principles and patterns in order to map existing tools and techniques adopted in the context of DevOps. Methodology: We conducted a Systematic Mapping Study identifying the goal and the research questions, the bibliographic sources, the search strings, and the selection criteria to retrieve the most relevant papers. Results: We identified several agreed microservice architectural principles and patterns widely adopted and reported in 23 case studies, together with a summary of the advantages, disadvantages, and lessons learned for each pattern from the case studies. Finally, we mapped the existing microservices-specific techniques in order to understand how to continuously deliver value in a DevOps pipeline. We depicted the current research, reporting gaps and trends. Conclusion: Different patterns emerge for different migration, orchestration, storage and deployment settings. The results also show the lack of empirical work on microservices-specific techniques, especially for the release phase in DevOps.},
	booktitle = {{CLOSER}},
	author = {Taibi, Davide and Lenarduzzi, Valentina and Pahl, Claus},
	year = {2018},
	keywords = {Cloud computing, Microservices, Software deployment, DevOps, Information system}
}

@inproceedings{gadea_reference_2016,
	address = {New York, NY, USA},
	series = {{CrossCloud} '16},
	title = {A {Reference} {Architecture} for {Real}-time {Microservice} {API} {Consumption}},
	isbn = {978-1-4503-4294-0},
	url = {http://doi.acm.org/10.1145/2904111.2904115},
	doi = {10.1145/2904111.2904115},
	abstract = {Modern web frameworks and backend-as-a-service providers make it possible for real-time updates to a NoSQL data model to be reflected in the user interfaces of multiple subscribing end-user applications. However, it remains difficult for users to dynamically discover and instantly make use of the data provided by the plethora of REST APIs in existence across various cloud providers today. This paper presents a reference architecture built on the idea of a scalable NoSQL database that allows multiple subscribers to receive instant notifications of database changes through the use of a "livequery". By keeping one WebSocket connection open between each client web browser and an Object Synchronization Server, this paper shows how data from multiple disparate REST APIs can be organized and transmitted to interested clients via the database. An example is given featuring a collaborative rich-text editor that makes use of a Named-Entity Recognition microservice.},
	urldate = {2019-12-17},
	booktitle = {Proceedings of the 3rd {Workshop} on {CrossCloud} {Infrastructures} \& {Platforms}},
	publisher = {ACM},
	author = {Gadea, Cristian and Trifan, Mircea and Ionescu, Dan and Ionescu, Bogdan},
	year = {2016},
	note = {event-place: London, United Kingdom},
	keywords = {cloud computing, microservices, collaborative editing, docker, named entity recognition, real-time web},
	pages = {2:1--2:6}
}

@article{pahl_architectural_2018,
	title = {Architectural {Principles} for {Cloud} {Software}},
	volume = {18},
	issn = {1533-5399},
	url = {http://doi.acm.org/10.1145/3104028},
	doi = {10.1145/3104028},
	abstract = {A cloud is a distributed Internet-based software system providing resources as tiered services. Through service-orientation and virtualization for resource provisioning, cloud applications can be deployed and managed dynamically. We discuss the building blocks of an architectural style for cloud-based software systems. We capture style-defining architectural principles and patterns for control-theoretic, model-based architectures for cloud software. While service orientation is agreed on in the form of service-oriented architecture and microservices, challenges resulting from multi-tiered, distributed and heterogeneous cloud architectures cause uncertainty that has not been sufficiently addressed. We define principles and patterns needed for effective development and operation of adaptive cloud-native systems.},
	number = {2},
	urldate = {2019-12-17},
	journal = {ACM Trans. Internet Technol.},
	author = {Pahl, Claus and Jamshidi, Pooyan and Zimmermann, Olaf},
	month = feb,
	year = {2018},
	keywords = {Cloud computing, microservice, software architecture, adaptive system, architectural style, cloud-native, control theory, devops, model-based controller, uncertainty},
	pages = {17:1--17:23}
}

@article{borges_algorithm_2019,
	title = {Algorithm for {Detecting} {Antipatterns} in {Microservices} {Projetcs}},
	abstract = {When migrating from a monolithic to a microservice-based architecture, one need to know patterns and antipatterns in order not to propagate old practices learned from centralized systems to a new structure where services are independent and distributed. We select 5 known antipatterns in microservices-based solutions and propose an algorithm for detecting them automatically. In a ﬁrst round, all classes, methods and imports are registered and associated to its location in the source code. In a second round the usage of these resources is mapped and antipatterns are detected. The algorithm is also responsible for generating visual output of how resources are used in the project, so the developers can manage how resources are distributed in diﬀerent ﬁles or concentrated in few ones. The solution can avoid common mistakes when deploying microservices-based projects and can help project managers to get an overview of the system as a whole. The algorithm is tested in a well-known open source project revealing possible improvements and resource allocation information.},
	language = {en},
	author = {Borges, Rodrigo and Khan, Tanveer},
	year = {2019},
	pages = {9},
	file = {Borges and Khan - Algorithm for Detecting Antipatterns in Microservi.pdf:C\:\\Users\\Speiser\\Zotero\\storage\\FJ9K55FJ\\Borges and Khan - Algorithm for Detecting Antipatterns in Microservi.pdf:application/pdf}
}

@article{krause_microservice_2020,
	title = {Microservice {Decomposition} via {Static} and {Dynamic} {Analysis} of the {Monolith}},
	url = {http://arxiv.org/abs/2003.02603},
	abstract = {Migrating monolithic software systems into microservices requires the application of decomposition techniquesto find and select appropriate service boundaries. These techniques are often based on domain knowledge, static code analysis, and non-functional requirements such as maintainability. In this paper, we present our experience with an approach that extends static analysis with dynamic analysis of a legacy software system's runtime behavior, including the live trace visualization to support the decomposition into microservices. Overall, our approach combines established analysis techniques for microservice decomposition, such as the bounded context pattern of domain-driven design, and enriches the collected information via dynamic software visualization to identify appropriate microservice boundaries. In collaboration with the German IT service provider adesso SE, we applied our approach to their real-word, legacy lottery application in{\textbar}FOCUS to identify good microservice decompositions for this layered monolithic Enterprise Java system.},
	urldate = {2020-03-11},
	journal = {arXiv:2003.02603 [cs]},
	author = {Krause, Alexander and Zirkelbach, Christian and Hasselbring, Wilhelm and Lenga, Stephan and Kröger, Dan},
	month = mar,
	year = {2020},
	note = {arXiv: 2003.02603},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\Speiser\\Zotero\\storage\\3VMWVIQP\\Krause et al. - 2020 - Microservice Decomposition via Static and Dynamic .pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\Speiser\\Zotero\\storage\\DR4K8QZF\\2003.html:text/html}
}

@inproceedings{baresi_microservices_2017,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Microservices {Identification} {Through} {Interface} {Analysis}},
	isbn = {978-3-319-67262-5},
	doi = {10.1007/978-3-319-67262-5_2},
	abstract = {The microservices architectural style is gaining more and more momentum for the development of applications as suites of small, autonomous, and conversational services, which are then easy to understand, deploy and scale. One of today’s problems is finding the adequate granularity and cohesiveness of microservices, both when starting a new project and when thinking of transforming, evolving and scaling existing applications. To cope with these problems, the paper proposes a solution based on the semantic similarity of foreseen/available functionality described through OpenAPI specifications. By leveraging a reference vocabulary, our approach identifies potential candidate microservices, as fine-grained groups of cohesive operations (and associated resources). We compared our approach against a state-of-the-art tool, sampled microservices-based applications and decomposed a large dataset of Web APIs. Results show that our approach is able to find suitable decompositions in some 80\% of the cases, while providing early insights about the right granularity and cohesiveness of obtained microservices.},
	language = {en},
	booktitle = {Service-{Oriented} and {Cloud} {Computing}},
	publisher = {Springer International Publishing},
	author = {Baresi, Luciano and Garriga, Martin and De Renzis, Alan},
	editor = {De Paoli, Flavio and Schulte, Stefan and Broch Johnsen, Einar},
	year = {2017},
	keywords = {Microservices, Microservice architecture, Monolith decomposition},
	pages = {19--33},
	file = {Submitted Version:C\:\\Users\\Speiser\\Zotero\\storage\\FZX63KQ5\\Baresi et al. - 2017 - Microservices Identification Through Interface Ana.pdf:application/pdf}
}

@inproceedings{gysel_service_2016,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Service {Cutter}: {A} {Systematic} {Approach} to {Service} {Decomposition}},
	isbn = {978-3-319-44482-6},
	shorttitle = {Service {Cutter}},
	doi = {10.1007/978-3-319-44482-6_12},
	abstract = {Decomposing a software system into smaller parts always has been a challenge in software engineering. It is particularly important to split distributed systems into loosely coupled and highly cohesive units. Service-oriented architectures and their microservices deployments tackle many related problems, but remain vague on how to cut a system into discrete, autonomous, network-accessible services. In this paper, we propose a structured, repeatable approach to service decomposition based on 16 coupling criteria distilled from the literature and industry experience. These coupling criteria form the base of Service Cutter, our method and tool framework for service decomposition. In the Service Cutter approach, coupling information is extracted from software engineering artifacts such as domain models and use cases and represented as an undirected, weighted graph to find and score densely connected clusters. The resulting candidate service cuts promise to reduce coupling between and promote high cohesion within services. In our validation activities, which included prototyping, action research and case studies, we successfully decomposed two sample applications with acceptable performance; most (but not all) test scenarios resulted in appropriate service cuts. These results as well as early feedback from members of the target audience in industry and academia suggest that our coupling criteria catalog and tool-supported service decomposition approach have the potential to assist a service architect’s design decisions in a viable and practical manner.},
	language = {en},
	booktitle = {Service-{Oriented} and {Cloud} {Computing}},
	publisher = {Springer International Publishing},
	author = {Gysel, Michael and Kölbener, Lukas and Giersche, Wolfgang and Zimmermann, Olaf},
	editor = {Aiello, Marco and Johnsen, Einar Broch and Dustdar, Schahram and Georgievski, Ilche},
	year = {2016},
	keywords = {Microservices, Functional partitioning, Knowledge management, Loose coupling, Service granularity, Service interface design guidelines, Service quality},
	pages = {185--200},
	file = {Submitted Version:C\:\\Users\\Speiser\\Zotero\\storage\\FYD4AC26\\Gysel et al. - 2016 - Service Cutter A Systematic Approach to Service D.pdf:application/pdf}
}

@inproceedings{bogner_towards_2019,
	title = {Towards a {Collaborative} {Repository} for the {Documentation} of {Service}-{Based} {Antipatterns} and {Bad} {Smells}},
	doi = {10.1109/ICSA-C.2019.00025},
	abstract = {While the concepts of object-oriented antipatterns and code smells are prevalent in scientific literature and have been popularized by tools like SonarQube, the research field for service-based antipatterns and bad smells is not as cohesive and organized. The description of these antipatterns is distributed across several publications with no holistic schema or taxonomy. Furthermore, there is currently little synergy between documented antipatterns for the architectural styles SOA and Microservices, even though several antipatterns may hold value for both. We therefore conducted a Systematic Literature Review (SLR) that identified 14 primary studies. 36 service-based antipatterns were extracted from these studies and documented with a holistic data model. We also categorized the antipatterns with a taxonomy and implemented relationships between them. Lastly, we developed a web application for convenient browsing and implemented a GitHub-based repository and workflow for the collaborative evolution of the collection. Researchers and practitioners can use the repository as a reference, for training and education, or for quality assurance.},
	booktitle = {2019 {IEEE} {International} {Conference} on {Software} {Architecture} {Companion} ({ICSA}-{C})},
	author = {Bogner, Justus and Boceck, Tobias and Popp, Matthias and Tschechlov, Dennis and Wagner, Stefan and Zimmermann, Alfred},
	month = mar,
	year = {2019},
	keywords = {microservices, Web services, Microservices, antipatterns, bad smells, code smells, Collaboration, collaborative repository, Documentation, GitHub-based repository, groupware, Libraries, object-oriented antipatterns, object-oriented programming, Search engines, service-based antipatterns, service-based systems, service-oriented architecture, Service-oriented architecture, SOA, systematic literature review, Taxonomy, Web application},
	pages = {95--101},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\XB8HJ6BG\\8712355.html:text/html}
}

@inproceedings{bogner_automatically_2017,
	address = {Gothenburg, Sweden},
	series = {{IWSM} {Mensura} '17},
	title = {Automatically measuring the maintainability of service- and microservice-based systems: a literature review},
	isbn = {978-1-4503-4853-9},
	shorttitle = {Automatically measuring the maintainability of service- and microservice-based systems},
	url = {https://doi.org/10.1145/3143434.3143443},
	doi = {10.1145/3143434.3143443},
	abstract = {In a time of digital transformation, the ability to quickly and efficiently adapt software systems to changed business requirements becomes more important than ever. Measuring the maintainability of software is therefore crucial for the long-term management of such products. With Service-based Systems (SBSs) being a very important form of enterprise software, we present a holistic overview of such metrics specifically designed for this type of system, since traditional metrics - e.g. object-oriented ones - are not fully applicable in this case. The selected metric candidates from the literature review were mapped to 4 dominant design properties: size, complexity, coupling, and cohesion. Microservice-based Systems (μSBSs) emerge as an agile and fine-grained variant of SBSs. While the majority of identified metrics are also applicable to this specialization (with some limitations), the large number of services in combination with technological heterogeneity and decentralization of control significantly impacts automatic metric collection in such a system. Our research therefore suggest that specialized tool support is required to guarantee the practical applicability of the presented metrics to μSBSs.},
	urldate = {2020-03-18},
	booktitle = {Proceedings of the 27th {International} {Workshop} on {Software} {Measurement} and 12th {International} {Conference} on {Software} {Process} and {Product} {Measurement}},
	publisher = {Association for Computing Machinery},
	author = {Bogner, Justus and Wagner, Stefan and Zimmermann, Alfred},
	month = oct,
	year = {2017},
	keywords = {microservices, service-based systems, SOA, maintainability, metrics},
	pages = {107--115}
}

@inproceedings{zimmermann_interface_2017,
	address = {Irsee, Germany},
	series = {{EuroPLoP} '17},
	title = {Interface {Representation} {Patterns}: {Crafting} and {Consuming} {Message}-{Based} {Remote} {APIs}},
	isbn = {978-1-4503-4848-5},
	shorttitle = {Interface {Representation} {Patterns}},
	url = {https://doi.org/10.1145/3147704.3147734},
	doi = {10.1145/3147704.3147734},
	abstract = {Remote Application Programming Interfaces (APIs) are technology enablers for major distributed system trends such as mobile and cloud computing and the Internet of Things. In such settings, message-based APIs dominate over procedural and object-oriented ones. It is hard to design such APIs so that they are easy and efficient to use for client developers. Maintaining their runtime qualities while preserving backward compatibility is equally challenging for API providers. For instance, finding a well suited granularity for services and their operations is a particularly important design concern in APIs that realize service-oriented software architectures. Due to the fallacies of distributed computing, the forces for message-based APIs and service interfaces differ from those for local APIs -- for instance, network latency and security concerns deserve special attention. Existing pattern languages have dealt with local APIs in object-oriented programming, with remote objects, with queue-based messaging and with service-oriented computing platforms. However, patterns or equivalent guidance for the structural design of request and response messages in message-based remote APIs is still missing. In this paper, we outline such a pattern language and introduce five basic interface representation patterns to promote platform-independent design advice for common remote API technologies such as RESTful HTTP and Web services (WSDL/SOAP). Known uses and examples of the patterns are drawn from public Web APIs, as well as application development and software integration projects the authors have been involved in.},
	urldate = {2020-03-18},
	booktitle = {Proceedings of the 22nd {European} {Conference} on {Pattern} {Languages} of {Programs}},
	publisher = {Association for Computing Machinery},
	author = {Zimmermann, Olaf and Stocker, Mirko and Lübke, Daniel and Zdun, Uwe},
	month = jul,
	year = {2017},
	pages = {1--36}
}

@article{zimmermann_microservices_2017,
	title = {Microservices tenets},
	volume = {32},
	issn = {1865-2042},
	url = {https://doi.org/10.1007/s00450-016-0337-0},
	doi = {10.1007/s00450-016-0337-0},
	abstract = {Some microservices proponents claim that microservices form a new architectural style; in contrast, advocates of service-oriented architecture (SOA) argue that microservices merely are an implementation approach to SOA. This overview and vision paper first reviews popular introductions to microservices to identify microservices tenets. It then compares two microservices definitions and contrasts them with SOA principles and patterns. This analysis confirms that microservices indeed can be seen as a development- and deployment-level variant of SOA; such microservices implementations have the potential to overcome the deficiencies of earlier approaches to SOA realizations by employing modern software engineering paradigms and Web technologies such as domain-driven design, RESTful HTTP, IDEAL cloud application architectures, polyglot persistence, lightweight containers, a continuous DevOps approach to service delivery, and comprehensive but lean fault management. However, these paradigms and technologies also cause a number of additional design choices to be made and create new options for many “distribution classics” type of architectural decisions. As a result, the cognitive load for (micro-)services architects increases, as well as the design, testing and maintenance efforts that are required to benefit from an adoption of microservices. To initiate and frame the buildup of architectural knowledge supporting microservices projects, this paper compiles related practitioner questions; it also derives research topics from these questions. The paper concludes with a summarizing position statement: microservices constitute one particular implementation approach to SOA (service development and deployment).},
	language = {en},
	number = {3},
	urldate = {2020-03-18},
	journal = {Computer Science - Research and Development},
	author = {Zimmermann, Olaf},
	month = jul,
	year = {2017},
	pages = {301--310}
}

@article{pautasso_microservices_2017,
	title = {Microservices in {Practice}, {Part} 1: {Reality} {Check} and {Service} {Design}},
	volume = {34},
	issn = {1937-4194},
	shorttitle = {Microservices in {Practice}, {Part} 1},
	doi = {10.1109/MS.2017.24},
	abstract = {Service-oriented architecture (SOA) and microservices insiders Mike Amundsen, James Lewis, and Nicolai Josuttis share their experiences and predictions with department editors Cesare Pautasso and Olaf Zimmermann.},
	number = {1},
	journal = {IEEE Software},
	author = {Pautasso, Cesare and Zimmermann, Olaf and Amundsen, Mike and Lewis, James and Josuttis, Nicolai},
	month = jan,
	year = {2017},
	note = {Conference Name: IEEE Software},
	keywords = {software architecture, software development, Software development, software engineering, Software engineering, microservices, Computer architecture, service-oriented architecture, Service-oriented architecture, SOA, Context modeling, Conway's law, DDD, domain-driven design, Extreme Programming, James Lewis, Mike Amundsen, Nicolai Josuttis, Semiconductor optical amplifiers, service design, Writing, XP},
	pages = {91--98},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\K6MYK3JD\\7819415.html:text/html}
}

@inproceedings{azadi_architectural_2019,
	address = {Montreal, Quebec, Canada},
	series = {{TechDebt} '19},
	title = {Architectural smells detected by tools: a catalogue proposal},
	shorttitle = {Architectural smells detected by tools},
	url = {https://doi.org/10.1109/TechDebt.2019.00027},
	doi = {10.1109/TechDebt.2019.00027},
	abstract = {Architectural smells can negatively impact on different software qualities and can represent a relevant source of architectural debt. Several architectural smells have been defined by different researchers. Moreover, both academia and industry proposed several tools for software quality analysis, but it is not always clear to understand which tools provide also support for architectural smells detection and if the tools developed for this specific purpose are effectively available or not. In this paper we propose a catalogue of architectural smells for which, at least one tool able to detect the smell exists. We outline the main differences in the detection techniques exploited by the tools and we propose a classification of these architectural smells according to the violation of three design principles.},
	urldate = {2020-03-20},
	booktitle = {Proceedings of the {Second} {International} {Conference} on {Technical} {Debt}},
	publisher = {IEEE Press},
	author = {Azadi, Umberto and Fontana, Francesca Arcelli and Taibi, Davide},
	month = may,
	year = {2019},
	keywords = {architectural smells, architectural debt, architectural smells catalogue, architectural smells detection},
	pages = {88--97}
}

@article{fontana_automatic_2012,
	title = {Automatic detection of bad smells in code: {An} experimental assessment},
	shorttitle = {Automatic detection of bad smells in code},
	doi = {10.5381/jot.2012.11.2.a5},
	abstract = {Code smells are structural characteristics of software that may indicate a code or design problem that makes software hard to evolve and maintain, and may trigger refactoring of code. Recent research is active in defining automatic detection tools to help humans in finding smells when code size becomes unmanageable for manual review. Since the definitions of code smells are informal and subjective, assessing how effective code smell detection tools are is both important and hard to achieve. This paper reviews the current panorama of the tools for automatic code smell detection. It defines research questions about the consistency of their responses, their ability to expose the regions of code most affected by structural decay, and the relevance of their responses with respect to future software evolution. It gives answers to them by analyzing the output of four representative code smell detectors applied to six different versions of GanttProject, an open source system written in Java. The results of these experiments cast light on what current code smell detection tools are able to do and what the relevant areas for further improvement are.},
	journal = {Journal of Object Technology},
	author = {Fontana, Francesca Arcelli and Braione, Pietro and Zanoni, Marco},
	year = {2012},
	file = {Full Text PDF:C\:\\Users\\Speiser\\Zotero\\storage\\QUWBCUZQ\\Fontana et al. - 2012 - Automatic detection of bad smells in code An expe.pdf:application/pdf}
}

@inproceedings{fernandes_review-based_2016,
	address = {Limerick, Ireland},
	series = {{EASE} '16},
	title = {A review-based comparative study of bad smell detection tools},
	isbn = {978-1-4503-3691-8},
	url = {https://doi.org/10.1145/2915970.2915984},
	doi = {10.1145/2915970.2915984},
	abstract = {Bad smells are symptoms that something may be wrong in the system design or code. There are many bad smells defined in the literature and detecting them is far from trivial. Therefore, several tools have been proposed to automate bad smell detection aiming to improve software maintainability. However, we lack a detailed study for summarizing and comparing the wide range of available tools. In this paper, we first present the findings of a systematic literature review of bad smell detection tools. As results of this review, we found 84 tools; 29 of them available online for download. Altogether, these tools aim to detect 61 bad smells by relying on at least six different detection techniques. They also target different programming languages, such as Java, C, C++, and C\#. Following up the systematic review, we present a comparative study of four detection tools with respect to two bad smells: Large Class and Long Method. This study relies on two software systems and three metrics for comparison: agreement, recall, and precision. Our findings support that tools provide redundant detection results for the same bad smell. Based on quantitative and qualitative data, we also discuss relevant usability issues and propose guidelines for developers of detection tools.},
	urldate = {2020-03-20},
	booktitle = {Proceedings of the 20th {International} {Conference} on {Evaluation} and {Assessment} in {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Fernandes, Eduardo and Oliveira, Johnatan and Vale, Gustavo and Paiva, Thanis and Figueiredo, Eduardo},
	month = jun,
	year = {2016},
	keywords = {bad smells, systematic literature review, comparative study, detection tools},
	pages = {1--12}
}

@article{arcelli_fontana_comparing_2016,
	title = {Comparing and experimenting machine learning techniques for code smell detection},
	volume = {21},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-015-9378-4},
	doi = {10.1007/s10664-015-9378-4},
	abstract = {Several code smell detection tools have been developed providing different results, because smells can be subjectively interpreted, and hence detected, in different ways. In this paper, we perform the largest experiment of applying machine learning algorithms to code smells to the best of our knowledge. We experiment 16 different machine-learning algorithms on four code smells (Data Class, Large Class, Feature Envy, Long Method) and 74 software systems, with 1986 manually validated code smell samples. We found that all algorithms achieved high performances in the cross-validation data set, yet the highest performances were obtained by J48 and Random Forest, while the worst performance were achieved by support vector machines. However, the lower prevalence of code smells, i.e., imbalanced data, in the entire data set caused varying performances that need to be addressed in the future studies. We conclude that the application of machine learning to the detection of these code smells can provide high accuracy ({\textgreater}96 \%), and only a hundred training examples are needed to reach at least 95 \% accuracy.},
	language = {en},
	number = {3},
	urldate = {2020-03-20},
	journal = {Empirical Software Engineering},
	author = {Arcelli Fontana, Francesca and Mäntylä, Mika V. and Zanoni, Marco and Marino, Alessandro},
	month = jun,
	year = {2016},
	pages = {1143--1191}
}

@inproceedings{di_nucci_detecting_2018,
	title = {Detecting code smells using machine learning techniques: {Are} we there yet?},
	shorttitle = {Detecting code smells using machine learning techniques},
	doi = {10.1109/SANER.2018.8330266},
	abstract = {Code smells are symptoms of poor design and implementation choices weighing heavily on the quality of produced source code. During the last decades several code smell detection tools have been proposed. However, the literature shows that the results of these tools can be subjective and are intrinsically tied to the nature and approach of the detection. In a recent work the use of Machine-Learning (ML) techniques for code smell detection has been proposed, possibly solving the issue of tool subjectivity giving to a learner the ability to discern between smelly and non-smelly source code elements. While this work opened a new perspective for code smell detection, it only considered the case where instances affected by a single type smell are contained in each dataset used to train and test the machine learners. In this work we replicate the study with a different dataset configuration containing instances of more than one type of smell. The results reveal that with this configuration the machine learning techniques reveal critical limitations in the state of the art which deserve further research.},
	booktitle = {2018 {IEEE} 25th {International} {Conference} on {Software} {Analysis}, {Evolution} and {Reengineering} ({SANER})},
	author = {Di Nucci, Dario and Palomba, Fabio and Tamburri, Damian A. and Serebrenik, Alexander and De Lucia, Andrea},
	month = mar,
	year = {2018},
	keywords = {software maintenance, Buildings, code smell detection, Code Smells, Detectors, Empirical Studies, learning (artificial intelligence), Machine Learning, machine learning techniques, Measurement, ML techniques, Predictive models, produced source code, Replication Study, single type smell, Software systems, source code elements, Tools, Training},
	pages = {612--621},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\NGWZQ8VZ\\8330266.html:text/html;Submitted Version:C\:\\Users\\Speiser\\Zotero\\storage\\YIGPKEDV\\Di Nucci et al. - 2018 - Detecting code smells using machine learning techn.pdf:application/pdf}
}

@article{al-shaaby_bad_2020,
	title = {Bad {Smell} {Detection} {Using} {Machine} {Learning} {Techniques}: {A} {Systematic} {Literature} {Review}},
	issn = {2191-4281},
	shorttitle = {Bad {Smell} {Detection} {Using} {Machine} {Learning} {Techniques}},
	url = {https://doi.org/10.1007/s13369-019-04311-w},
	doi = {10.1007/s13369-019-04311-w},
	abstract = {Code smells are indicators of potential problems in software. They tend to have a negative impact on software quality. Several studies use machine learning techniques to detect bad smells. The objective of this study is to systematically review and analyze machine learning techniques used to detect code smells to provide interested research community with knowledge about the adopted techniques and practices for code smells detection. We use a systematic literature review approach to review studies that use machine learning techniques to detect code smells. Seventeen primary studies were identified. We found that 27 code smells were used in the identified studies; God Class and Long Method, Feature Envy, and Data Class are the most frequently detected code smells. In addition, we found that 16 machine learning algorithms were employed to detect code smells with acceptable prediction accuracy. Furthermore, we the results also indicate that support vector machine techniques were investigated the most. Moreover, we observed that J48 and Random Forest algorithms outperform the other algorithms. We also noticed that, in some cases, the use of boosting techniques on the models does not always enhance their performance. More studies are needed to consider the use of ensemble learning techniques, multiclassification, and feature selection technique for code smells detection. Thus, the application of machine learning algorithms to detect code smells in systems is still in its infancy and needs more research to facilitate the employment of machine learning algorithms in detecting code smells.},
	language = {en},
	urldate = {2020-03-20},
	journal = {Arabian Journal for Science and Engineering},
	author = {Al-Shaaby, Ahmed and Aljamaan, Hamoud and Alshayeb, Mohammad},
	month = jan,
	year = {2020}
}

@inproceedings{fontana_arcan_2017,
	title = {Arcan: {A} {Tool} for {Architectural} {Smells} {Detection}},
	shorttitle = {Arcan},
	doi = {10.1109/ICSAW.2017.16},
	abstract = {Code smells are sub-optimal coding circumstances such as blob classes or spaghetti code - they have received much attention and tooling in recent software engineering research. Higher-up in the abstraction level, architectural smells are problems or sub-optimal architectural patterns or other design-level characteristics. These have received significantly less attention even though they are usually considered more critical than code smells, and harder to detect, remove, and refactor. This paper describes an open-source tool called Arcan developed for the detection of architectural smells through an evaluation of several different architecture dependency issues. The detection techniques inside Arcan exploit graph database technology, allowing for high scalability in smells detection and better management of large amounts of dependencies of multiple kinds. In the scope of this paper, we focus on the evaluation of Arcan results carried out with real-life software developers to check if the architectural smells detected by Arcan are really perceived as problems and to get an overall usefulness evaluation of the tool.},
	booktitle = {2017 {IEEE} {International} {Conference} on {Software} {Architecture} {Workshops} ({ICSAW})},
	author = {Fontana, Francesca Arcelli and Pigazzini, Ilaria and Roveda, Riccardo and Tamburri, Damian and Zanoni, Marco and Nitto, Elisabetta Di},
	month = apr,
	year = {2017},
	keywords = {public domain software, software architecture, Software architecture, software quality, Computer architecture, code smells, Measurement, Tools, abstraction level, Arcan, architectural smell detection, Architectural Smells, architecture dependency issue evaluation, database management systems, Databases, Dependency graph, design-level characteristics, Graph database, graph database technology, graph theory, Java, open-source tool, Shape, Software, software developers, software engineering research, software tools, source code (software), suboptimal architectural patterns},
	pages = {282--285},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\8CEFXY54\\7958506.html:text/html;Submitted Version:C\:\\Users\\Speiser\\Zotero\\storage\\M86FANHM\\Fontana et al. - 2017 - Arcan A Tool for Architectural Smells Detection.pdf:application/pdf}
}

@inproceedings{fontana_automatic_2016,
	title = {Automatic {Detection} of {Instability} {Architectural} {Smells}},
	doi = {10.1109/ICSME.2016.33},
	abstract = {Code smells represent well known symptoms of problems at code level, and architectural smells can be seen as their counterpart at architecture level. If identified in a system, they are usually considered more critical than code smells, for their effect on maintainability issues. In this paper, we introduce a tool for the detection of architectural smells that could have an impact on the stability of a system. The detection techniques are based on the analysis of dependency graphs extracted from compiled Java projects and stored in a graph database. The results combine the information gathered from dependency and instability metrics to identify flaws hidden in the software architecture. We also propose some filters trying to avoid possible false positives.},
	booktitle = {2016 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	author = {Fontana, Francesca Arcelli and Pigazzini, Ilaria and Roveda, Riccardo and Zanoni, Marco},
	month = oct,
	year = {2016},
	keywords = {software architecture, software quality, software maintenance, code smells, Detectors, Measurement, Architectural Smells, Databases, Java, Software, dependency graphs, dependency metrics, Design Metrics, Engines, Filtering algorithms, graph database, instability architectural smells detection, instability metrics, Java projects, maintainability issues, Software Architecture Evaluation},
	pages = {433--437},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\D6GACBJX\\7816489.html:text/html}
}

@inproceedings{biaggi_architectural_2018,
	title = {An {Architectural} {Smells} {Detection} {Tool} for {C} and {C}++ {Projects}},
	doi = {10.1109/SEAA.2018.00074},
	abstract = {Architectural smells gained great attention in the past few years since they directly affect software quality and increase architectural technical debt. However, while it is straight-forward to understand why they are important, it is more difficult to find techniques and tools to detect and remove architectural smells. The purpose of this paper is to introduce an open-source tool for automatic architectural smells detection for C/C++ projects, by creating an abstraction of the project and defining the concept of dependency between elements belonging to the project in order to identify architectural smells. The tool has been validated on some open-source projects with promising results.},
	booktitle = {2018 44th {Euromicro} {Conference} on {Software} {Engineering} and {Advanced} {Applications} ({SEAA})},
	author = {Biaggi, Andrea and Arcelli Fontana, Francesca and Roveda, Riccardo},
	month = aug,
	year = {2018},
	keywords = {public domain software, software architecture, software quality, Computer architecture, software maintenance, Measurement, Tools, Java, open-source tool, Engines, architectural smells detection tool, Architectural Smells, Architectural Technical Debt, Software Architecture Evaluation, Standard C, C++, architectural technical debt, automatic architectural smells detection, C projects, C++ language, C++ languages, C++ projects, Image edge detection, open-source projects, program diagnostics},
	pages = {417--420},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\NY6TIZ4M\\authors.html:text/html}
}

@incollection{dragoni_microservices_2017,
	address = {Cham},
	title = {Microservices: {Yesterday}, {Today}, and {Tomorrow}},
	isbn = {978-3-319-67425-4},
	shorttitle = {Microservices},
	url = {https://doi.org/10.1007/978-3-319-67425-4_12},
	abstract = {Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Before presenting the current state of the art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out a few potential solutions.},
	language = {en},
	urldate = {2020-03-25},
	booktitle = {Present and {Ulterior} {Software} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Dragoni, Nicola and Giallorenzo, Saverio and Lafuente, Alberto Lluch and Mazzara, Manuel and Montesi, Fabrizio and Mustafin, Ruslan and Safina, Larisa},
	editor = {Mazzara, Manuel and Meyer, Bertrand},
	year = {2017},
	doi = {10.1007/978-3-319-67425-4_12},
	pages = {195--216},
	file = {Submitted Version:C\:\\Users\\Speiser\\Zotero\\storage\\AE3636MZ\\Dragoni et al. - 2017 - Microservices Yesterday, Today, and Tomorrow.pdf:application/pdf}
}

@inproceedings{chen_monolith_2017,
	title = {From {Monolith} to {Microservices}: {A} {Dataflow}-{Driven} {Approach}},
	shorttitle = {From {Monolith} to {Microservices}},
	doi = {10.1109/APSEC.2017.53},
	abstract = {Emerging from the agile practitioner communities, the microservice-oriented architecture emphasizes implementing and employing multiple small-scale and independently deployable microservices, rather than encapsulating all function capabilities into one monolithic application. Correspondingly, microservice-oriented decomposition, which has been identified to be an extremely challenging and complex task, plays a crucial and prerequisite role in developing microservice-based software systems. To address this challenge and reduce the complexity, we proposed a top-down analysis approach and developed a dataflow-driven decomposition algorithm. In brief, a three-step process is defined: first, engineers together with users conduct business requirement analysis and construct a purified while detailed dataflow diagram of the business logic; then, our algorithm combines the same operations with the same type of output data into a virtual abstract dataflow; finally, the algorithm extracts individual modules of "operation and its output data" from the virtual abstract dataflow to represent the identified microservice candidates. We have employed two use cases to demonstrate our microservice identification mechanism, as well as making comparisons with an existing microservice identification tool. The comparison and evaluation show that, our dataflow-driven identification mechanism is able to deliver more rational, objective, understandable and consistent microservice candidates, through a more rigorous and practical implementation procedure.},
	booktitle = {2017 24th {Asia}-{Pacific} {Software} {Engineering} {Conference} ({APSEC})},
	author = {Chen, Rui and Li, Shanshan and Li, Zheng},
	month = dec,
	year = {2017},
	keywords = {microservices, Computer architecture, service-oriented architecture, Service-oriented architecture, agile practitioner communities, analysis approach, Business, business logic, business requirement analysis, Complexity theory, data flow, data flow computing, Data mining, dataflow-driven approach, dataflow-driven decomposition algorithm, decomposition, Electronic mail, independently deployable microservices, microservice candidates, microservice identification mechanism, microservice identification tool, microservice-based software systems, monolith, monolithic application, multiple small-scale microservices, virtual abstract dataflow},
	pages = {466--475},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\II5DP9J7\\8305969.html:text/html}
}

@article{al-debagy_comparative_2019,
	title = {A {Comparative} {Review} of {Microservices} and {Monolithic} {Architectures}},
	url = {http://arxiv.org/abs/1905.07997},
	abstract = {Microservices' architecture is getting attention in the academic community and the industry, and mostly is compared with monolithic architecture. Plenty of the results of these research papers contradict each other regarding the performance of these architectures. Therefore, these two architectures are compared in this paper, and some specific configurations of microservices' applications are evaluated as well in the term of service discovery. Monolithic architecture in concurrency testing showed better performance in throughput by 6\% when compared to microservices architecture. The load testing scenario did not present significant difference between the two architectures. Furthermore, a third test comparing microservices applications built with different service discovery technologies such as Consul and Eureka showed that applications with Consul presented better results in terms of throughput.},
	urldate = {2020-03-25},
	journal = {arXiv:1905.07997 [cs]},
	author = {Al-Debagy, Omar and Martinek, Peter},
	month = may,
	year = {2019},
	note = {arXiv: 1905.07997},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\Speiser\\Zotero\\storage\\KXMACXL9\\Al-Debagy and Martinek - 2019 - A Comparative Review of Microservices and Monolith.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\Speiser\\Zotero\\storage\\XJ39IIJ7\\1905.html:text/html}
}

@inproceedings{le_empirical_2015,
	title = {An {Empirical} {Study} of {Architectural} {Change} in {Open}-{Source} {Software} {Systems}},
	doi = {10.1109/MSR.2015.29},
	abstract = {From its very inception, the study of software architecture has recognized architectural decay as a regularly occurring phenomenon in long-lived systems. Architectural decay is caused by repeated changes to a system during its lifespan. Despite decay's prevalence, there is a relative dearth of empirical data regarding the nature of architectural changes that may lead to decay, and of developers' understanding of those changes. In this paper, we take a step toward addressing that scarcity by conducting an empirical study of changes found in software architectures spanning several hundred versions of 14 open-source systems. Our study reveals several new findings regarding the frequency of architectural changes in software systems, the common points of departure in a system's architecture during maintenance and evolution, the difference between system-level and component-level architectural change, and the suitability of a system's implementation-level structure as a proxy for its architecture.},
	booktitle = {2015 {IEEE}/{ACM} 12th {Working} {Conference} on {Mining} {Software} {Repositories}},
	author = {Le, Duc Minh and Behnamghader, Pooyan and Garcia, Joshua and Link, Daniel and Shahbazian, Arman and Medvidovic, Nenad},
	month = may,
	year = {2015},
	note = {ISSN: 2160-1860},
	keywords = {public domain software, software architecture, Computer architecture, software maintenance, object-oriented programming, Measurement, Software systems, Accuracy, architectural change, architectural decay, architecture recovery, Clustering algorithms, component-level architectural change, long-lived systems, open-source software systems, open-source systems, software evolution, System implementation, system-level architectural change},
	pages = {235--245},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\GE6YH59Q\\7180083.html:text/html}
}

@inproceedings{garcia_toward_2009,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Toward a {Catalogue} of {Architectural} {Bad} {Smells}},
	isbn = {978-3-642-02351-4},
	doi = {10.1007/978-3-642-02351-4_10},
	abstract = {An architectural bad smell is a commonly (although not always intentionally) used set of architectural design decisions that negatively impacts system lifecycle properties, such as understandability, testability, extensibility, and reusability. In our previous short paper, we introduced the notion of architectural bad smells and outlined a few common smells. In this paper, we significantly expand upon that work. In particular, we describe in detail four representative architectural smells that emerged from reverse-engineering and re-engineering two large industrial systems and from our search through case studies in research literature. For each of the four architectural smells, we provide illustrative examples and demonstrate the smell’s impact on system lifecycle properties. Our experiences indicate the need to identify and catalog architectural smells so that software architects can discover and eliminate them from system designs.},
	language = {en},
	booktitle = {Architectures for {Adaptive} {Software} {Systems}},
	publisher = {Springer},
	author = {Garcia, Joshua and Popescu, Daniel and Edwards, George and Medvidovic, Nenad},
	editor = {Mirandola, Raffaela and Gorton, Ian and Hofmeister, Christine},
	year = {2009},
	keywords = {Grid Technology, Procedure Call, Resource Discovery, Software Architecture, Software Engineer},
	pages = {146--162}
}

@inproceedings{garcia_identifying_2009,
	title = {Identifying {Architectural} {Bad} {Smells}},
	doi = {10.1109/CSMR.2009.59},
	abstract = {Certain design fragments in software architectures can have a negative impact on system maintainability. In this paper, we introduce the concept of architectural "bad smells," which are frequently recurring software designs that can have non-obvious and significant detrimental effects on system lifecycle properties. We define architectural smells and differentiate them from related concepts, such as architectural antipatterns and code smells. We also describe four representative architectural smells we encountered in the context of reverse-engineering eighteen grid technologies and refactoring one large industrial system.},
	booktitle = {2009 13th {European} {Conference} on {Software} {Maintenance} and {Reengineering}},
	author = {Garcia, Joshua and Popescu, Daniel and Edwards, George and Medvidovic, Nenad},
	month = mar,
	year = {2009},
	note = {ISSN: 1534-5351},
	keywords = {Application software, architectural bad smell identification, Architectural Bad Smells, Architectural Refactoring, Computer architecture, Computer industry, Computer science, Design engineering, design fragments, grid computing, grid technologies, industrial system refactoring, reverse engineering, software architecture, Software architecture, Software Architecture, software architectures, Software design, software maintenance, Software maintenance, Software Maintenance, Software systems, system lifecycle properties, system maintainability, Technology management},
	pages = {255--258},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\JUMW3SU5\\4812762.html:text/html}
}

@inproceedings{ernst_measure_2015,
	address = {Bergamo, Italy},
	series = {{ESEC}/{FSE} 2015},
	title = {Measure it? {Manage} it? {Ignore} it? software practitioners and technical debt},
	isbn = {978-1-4503-3675-8},
	shorttitle = {Measure it?},
	url = {https://doi.org/10.1145/2786805.2786848},
	doi = {10.1145/2786805.2786848},
	abstract = {The technical debt metaphor is widely used to encapsulate numerous software quality problems. The metaphor is attractive to practitioners as it communicates to both technical and nontechnical audiences that if quality problems are not addressed, things may get worse. However, it is unclear whether there are practices that move this metaphor beyond a mere communication mechanism. Existing studies of technical debt have largely focused on code metrics and small surveys of developers. In this paper, we report on our survey of 1,831 participants, primarily software engineers and architects working in long-lived, software-intensive projects from three large organizations, and follow-up interviews of seven software engineers. We analyzed our data using both nonparametric statistics and qualitative text analysis. We found that architectural decisions are the most important source of technical debt. Furthermore, while respondents believe the metaphor is itself important for communication, existing tools are not currently helpful in managing the details. We use our results to motivate a technical debt timeline to focus management and tooling approaches.},
	urldate = {2020-03-26},
	booktitle = {Proceedings of the 2015 10th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Ernst, Neil A. and Bellomo, Stephany and Ozkaya, Ipek and Nord, Robert L. and Gorton, Ian},
	month = aug,
	year = {2015},
	keywords = {architecture, survey, Technical debt},
	pages = {50--60}
}

@inproceedings{macia_relevance_2012,
	title = {On the {Relevance} of {Code} {Anomalies} for {Identifying} {Architecture} {Degradation} {Symptoms}},
	doi = {10.1109/CSMR.2012.35},
	abstract = {The longevity of evolving software systems largely depends on their resilience to architectural design degradation. It is often assumed that code anomalies are always key indicators of architecture degradation symptoms. The problem is that there is still limited knowledge about the circumstances under which code anomalies represent architectural problems. Without this knowledge, developers are not able to implement architecturally-relevant strategies for code refactoring. This paper presents an empirical study about the influence of code anomalies on architecture degradation symptoms. To this end, we studied the relationship between code anomalies and architecture problems in 6 software systems, which were intended to adhere different architectural decompositions. A total of 40 versions and 2056 code anomalies were analyzed. Our study revealed that 78\% of all architecture problems in the programs were related to code anomalies. In particular, more than 33\% of all architecture problems were unexpectedly induced by anomalous code elements in the systems' first version. We also found that the refactoring strategies, even when frequently applied in those systems, did not significantly contribute to remove architecturally-relevant code anomalies.},
	booktitle = {2012 16th {European} {Conference} on {Software} {Maintenance} and {Reengineering}},
	author = {Macia, Isela and Arcoverde, Roberta and Garcia, Alessandro and Chavez, Christina and von Staa, Arndt},
	month = mar,
	year = {2012},
	note = {ISSN: 1534-5351},
	keywords = {anomalous code elements, architectural anomaly, architectural decompositions, architectural design degradation, architectural violation, architecturally-relevant code anomalies, architecture degradation symptoms, Business, code anomaly, code refactoring, Computer architecture, Degradation, Documentation, evolving software systems, Graphical user interfaces, Java, refactoring, Software, software architecture, software maintenance},
	pages = {277--286},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\ND8PLPYY\\6178894.html:text/html}
}

@inproceedings{yuanfang_cai_detecting_2017,
	title = {Detecting and {Quantifying} {Architectural} {Debt}: {Theory} and {Practice}},
	shorttitle = {Detecting and {Quantifying} {Architectural} {Debt}},
	doi = {10.1109/ICSE-C.2017.165},
	abstract = {In this technical briefing, we will introduce the theory, practice, and tool support for detecting and quantifying architectural debt. We will introduce the concept of design rule space (DRSpace)-a new architectural model forming the foundation of architectural debt detection, hotspot patterns- recurring architectural flaws leading to architectural debt, and architectural debt quantification.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Yuanfang Cai and Kazman, Rick},
	month = may,
	year = {2017},
	keywords = {architectural debt detection, architectural debt quantification, Computer architecture, Computer bugs, design rule space, DRSpace, hotspot patterns, recurring architectural flaws, software architecture, Software architecture, software design, software metrics, Software systems, technical debt, Tools},
	pages = {503--504},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Speiser\\Zotero\\storage\\CIFNF45S\\7965404.html:text/html}
}